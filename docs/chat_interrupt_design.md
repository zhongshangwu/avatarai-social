# 聊天中断机制设计文档

## 设计哲学

### 核心原则

1. **非阻塞性** - 中断请求不应阻塞调用者，确保用户界面的响应性
2. **可靠性** - 中断信号必须能够可靠传达到处理层
3. **优雅性** - 中断应该允许当前操作优雅完成，避免数据丢失
4. **简洁性** - 避免过度设计，专注核心功能
5. **Fire-and-Forget** - 遵循Unix信号的传统设计，发送后立即返回

### 分层控制架构

```
用户层 (WebSocket客户端)
    ↓ 中断事件 (fire-and-forget)
协调层 (ChatActor)
    ↓ 控制信号 (fire-and-forget)
执行层 (ChatRunner)
    ↓ 流控制
资源层 (LLM流/网络连接)
```

## 问题分析

### 原始问题

1. **阻塞写入**: `ControlChan <- ctx.CtrlType` 在通道满时会永久阻塞
2. **通道不一致**: `ChatRunner.ctrlChan` 和 `ChatInvokeContext.ControlChan` 混用
3. **资源泄漏**: 中断时没有正确清理流和连接

### 解决方案

#### 1. Fire-and-Forget控制信号发送

```go
select {
case invokeCtx.ControlChan <- ctx.CtrlType:
    // 成功发送，立即返回
    return nil
case <-time.After(100 * time.Millisecond):
    // 超时处理
    return errors.New("控制信号发送超时")
}
```

**关键设计决策：不等待信号处理完成**

这遵循了Unix信号的传统设计：
- `kill -9 <pid>` 立即返回，不等待进程被杀死
- Ctrl-C 发送SIGINT后，终端立即响应
- Kubernetes发送SIGTERM后，开始倒计时而不等待确认

#### 2. 统一控制通道

- 移除 `ChatRunner.ctrlChan`
- 统一使用 `ChatInvokeContext.ControlChan`
- 增加缓冲区大小到10，减少阻塞概率

#### 3. 依赖现有机制

- **Context生命周期**: 使用 `ctx.Context.Done()` 判断会话状态
- **通道状态**: 通道的开闭状态本身就代表了处理状态
- **原子操作**: Go通道操作天然具备原子性

#### 4. 中断控制类型

```go
const (
    CtrlTypeInterrupt CtrlType = "interrupt" // 用户主动中断
)
```

## 实现细节

### 控制流程

1. **中断请求**: 客户端发送中断事件
2. **信号传递**: ChatActor调用ChatRunner.Ctrl()
3. **Fire-and-Forget发送**: 使用select语句发送信号后立即返回
4. **异步处理**: 处理循环独立处理中断信号
5. **资源清理**: 关闭流，清理连接
6. **响应发送**: 发送中断完成事件

### 为什么采用Fire-and-Forget模式

**符合Unix传统**：
- Unix信号设计就是异步、非阻塞的
- 发送者不需要知道接收者何时处理完成
- 这是几十年来验证过的设计模式

**避免复杂性**：
- 不需要复杂的同步机制
- 避免死锁和竞态条件
- 简化错误处理

**更好的用户体验**：
- 用户操作立即响应
- 不会因为后端处理而卡顿
- 符合用户对中断操作的预期

### 超时机制

- **发送超时**: 100ms，避免长时间阻塞
- **不等待处理完成**: 发送成功后立即返回
- **优雅降级**: 超时后返回错误，不会无限等待

## 使用示例

### 基本中断

```go
// 客户端发送中断事件
interruptEvent := &messages.ChatEvent{
    EventType: messages.EventTypeAIChatInterrupt,
    Event: &messages.InterruptEvent{},
}

// 系统自动处理中断流程 - fire-and-forget
```

## 设计优势

1. **响应性**: 用户操作不会被阻塞
2. **可靠性**: 控制信号能够可靠传达
3. **简洁性**:
   - 无需额外的状态管理
   - 依赖Go原生的Context和Channel机制
   - 减少代码复杂度和维护成本
4. **健壮性**: 有完善的超时和错误处理
5. **可观测性**: 详细的日志记录
6. **Unix兼容性**: 遵循传统Unix信号语义

## 为什么不等待信号处理完成

1. **Unix哲学**: 信号本质上是异步的，发送者不应该等待
2. **避免死锁**: 等待可能导致复杂的同步问题
3. **用户体验**: 立即响应用户操作
4. **简化设计**: 减少状态管理的复杂性
5. **主流实践**: 所有主流系统都采用fire-and-forget模式

## 注意事项

1. **缓冲区大小**: ControlChan缓冲区设为10，需要根据实际负载调整
2. **超时时间**: 发送超时100ms，可根据需要调整
3. **资源清理**: 确保在所有退出路径上都正确清理资源
4. **错误处理**: 依赖函数返回值和日志进行错误跟踪
5. **幂等性**: 多次发送同一信号应该是安全的

## 未来改进

1. **监控指标**: 添加中断成功率、响应时间等监控指标
2. **批量操作**: 支持批量中断多个会话
3. **持久化**: 如果需要，可以在业务层添加持久化逻辑